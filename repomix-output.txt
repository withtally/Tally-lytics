This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-06-05T17:37:59.976Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
cron/
  package.json
  railway.toml
  run-cron.sh
cron-crawler/
  Dockerfile
  package.json
  railway.toml
db/
  migrations/
    20250310153157_add_cron_job_history_table.cjs
services/
  cron/
    __tests__/
      jobTrackingService.test.ts
    commonTopicsCron.ts
    cronManager.ts
    jobTrackingService.ts
  server/
    cron.ts
    cronStatusRoutes.ts

================================================================
Files
================================================================

================
File: cron/package.json
================
{
    "name": "cron-service",
    "version": "1.0.0",
    "description": "Cron service for scheduling API calls",
    "main": "index.js",
    "scripts": {
      "start": "echo 'Cron service ready'"
    },
    "dependencies": {
      "curl": "^0.1.4"
    },
    "engines": {
      "node": ">=16.0.0"
    }
  }

================
File: cron/railway.toml
================
[build]
builder = "nixpacks"
buildCommand = "echo 'No build needed for cron service' && chmod +x ./run-cron.sh"

[deploy]
startCommand = "./run-cron.sh"

================
File: cron/run-cron.sh
================
#!/bin/sh
# Script to execute cron job with detailed logging

# Log start time
echo "========================================" 
echo "Cron job started at $(date)"

# Check if MAIN_SERVICE_URL is set
if [ -z "$MAIN_SERVICE_URL" ]; then
  echo "ERROR: MAIN_SERVICE_URL environment variable is not set!"
  echo "Please set this variable in your Railway project configuration."
  echo "Example: https://your-main-service.railway.app"
  
  # Try to use a default URL if available
  DEFAULT_URL="https://web-production-88af4.up.railway.app"
  echo "Attempting to use default URL: $DEFAULT_URL"
  MAIN_SERVICE_URL="$DEFAULT_URL"
fi

echo "Attempting to call: $MAIN_SERVICE_URL/api/crawl/start/all"

# Execute the curl command with verbose output
curl -v -X POST $MAIN_SERVICE_URL/api/crawl/start/all -H 'Content-Type: application/json'

# Log the exit status
EXIT_CODE=$?
echo "Curl command completed with exit code: $EXIT_CODE"

# Additional environment debugging
echo "Environment variables:"
echo "MAIN_SERVICE_URL: $MAIN_SERVICE_URL"
echo "NODE_ENV: $NODE_ENV"

echo "Cron job finished at $(date)"
echo "========================================"

# Return the exit code from curl
exit $EXIT_CODE

================
File: cron-crawler/Dockerfile
================
FROM node:18-slim

WORKDIR /app

# Install curl
RUN apt-get update && apt-get install -y curl && apt-get clean

# Set environment variables
ENV NODE_ENV=production

# Create a simple script to run the curl command with error handling
RUN echo '#!/bin/sh\n\
echo "Cron job started at $(date)"\n\
# Check if MAIN_SERVICE_URL is set\n\
if [ -z "$MAIN_SERVICE_URL" ]; then\n\
  echo "ERROR: MAIN_SERVICE_URL environment variable is not set!"\n\
  echo "Attempting to use default URL: https://web-production-88af4.up.railway.app"\n\
  MAIN_SERVICE_URL="https://web-production-88af4.up.railway.app"\n\
fi\n\
echo "Calling: $MAIN_SERVICE_URL/api/crawl/start/all"\n\
curl -v -X POST $MAIN_SERVICE_URL/api/crawl/start/all -H "Content-Type: application/json"\n\
EXIT_CODE=$?\n\
echo "Environment variables:"\n\
echo "MAIN_SERVICE_URL: $MAIN_SERVICE_URL"\n\
echo "NODE_ENV: $NODE_ENV"\n\
echo "Curl completed with exit code: $EXIT_CODE at $(date)"\n\
' > /app/run.sh
RUN chmod +x /app/run.sh

# Set the command to run
CMD ["/app/run.sh"]

================
File: cron-crawler/package.json
================
{
  "name": "crawler-cron",
  "version": "1.0.0",
  "description": "Crawler cron service",
  "main": "index.js",
  "scripts": {
    "start": "curl -v -X POST $MAIN_SERVICE_URL/api/crawl/start/all -H 'Content-Type: application/json'"
  },
  "engines": {
    "node": ">=14"
  }
}

================
File: cron-crawler/railway.toml
================
[build]
builder = "nixpacks"
buildCommand = "echo 'Skipping build for cron service'"
ignoreBuildCommand = true

[deploy]
startCommand = "curl -X POST $MAIN_SERVICE_URL/api/crawl/start-all -H 'Content-Type: application/json'"
restartPolicyType = "never"
ignoreProcfile = true

[cron]
schedule = "0 */2 * * *"

================
File: db/migrations/20250310153157_add_cron_job_history_table.cjs
================
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function (knex) {
  return knex.schema.createTable('cron_job_history', function (table) {
    table.increments('id').primary();
    table.string('job_name').notNullable();
    table.string('status').notNullable();
    table.text('message');
    table.timestamp('started_at').defaultTo(knex.fn.now());
    table.timestamp('completed_at');
    table.integer('duration_ms');

    // Add indexes
    table.index('job_name');
    table.index('status');
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function (knex) {
  return knex.schema.dropTable('cron_job_history');
};

================
File: services/cron/__tests__/jobTrackingService.test.ts
================
// services/cron/__tests__/jobTrackingService.test.ts

import { describe, it, expect } from '@jest/globals';
import { JobTrackingService, JobStatus } from '../jobTrackingService';

describe('JobTrackingService', () => {
  it('should export JobTrackingService as a constructor', () => {
    expect(JobTrackingService).toBeDefined();
    expect(typeof JobTrackingService).toBe('function');
  });

  it('should export JobStatus enum', () => {
    expect(JobStatus).toBeDefined();
    expect(JobStatus.RUNNING).toBe('running');
    expect(JobStatus.COMPLETED).toBe('completed');
    expect(JobStatus.FAILED).toBe('failed');
  });

  it('should have a constructor with no parameters', () => {
    expect(JobTrackingService.length).toBe(0);
  });

  it('should have required job tracking methods', () => {
    const instance = new JobTrackingService();
    
    expect(typeof instance.startJob).toBe('function');
    expect(typeof instance.completeJob).toBe('function');
    expect(typeof instance.failJob).toBe('function');
    expect(typeof instance.getRecentJobs).toBe('function');
    expect(typeof instance.getLastSuccessfulRun).toBe('function');
    expect(typeof instance.cleanupOldJobs).toBe('function');
    expect(typeof instance.getJobStats).toBe('function');
    expect(typeof instance.updateJobMetadata).toBe('function');
  });

  it('should have startJob method with 2 parameters', () => {
    const instance = new JobTrackingService();
    expect(instance.startJob.length).toBe(2);
  });

  it('should have completeJob method with 2 parameters', () => {
    const instance = new JobTrackingService();
    expect(instance.completeJob.length).toBe(2);
  });

  it('should have failJob method with 2 parameters', () => {
    const instance = new JobTrackingService();
    expect(instance.failJob.length).toBe(2);
  });

  it('should have getRecentJobs method with 2 parameters', () => {
    const instance = new JobTrackingService();
    expect(instance.getRecentJobs.length).toBe(2);
  });

  it('should have getLastSuccessfulRun method with 1 parameter', () => {
    const instance = new JobTrackingService();
    expect(instance.getLastSuccessfulRun.length).toBe(1);
  });

  it('should have cleanupOldJobs method with 1 parameter', () => {
    const instance = new JobTrackingService();
    expect(instance.cleanupOldJobs.length).toBe(1);
  });

  it('should have getJobStats method with 1 parameter', () => {
    const instance = new JobTrackingService();
    expect(instance.getJobStats.length).toBe(1);
  });

  it('should have updateJobMetadata method with 2 parameters', () => {
    const instance = new JobTrackingService();
    expect(instance.updateJobMetadata.length).toBe(2);
  });
});

================
File: services/cron/commonTopicsCron.ts
================
import { CronJob } from 'cron';
import { Logger } from '../logging';
import { commonTopicsService } from '../topics/commonTopicsService';
import db from '../../db/db';
import { LoggingConfig } from '../logging/types';
import { forumConfigs } from '../../config/forumConfig';

const logger = new Logger({
  logFile: 'logs/common-topics-cron.log',
  level: 'info',
} as LoggingConfig);

export class CommonTopicsCron {
  private job: CronJob;
  private timeframe: string;

  /**
   * @param {string} schedule - Cron schedule expression (default: '0 0 * * *' - daily at midnight)
   * @param {string} timeframe - Time range in PostgreSQL interval format (e.g., '7d', '2 weeks', '1 month')
   */
  constructor(schedule = '0 0 * * *', timeframe = '14d') {
    // Default: Run daily at midnight
    this.timeframe = timeframe;
    this.job = new CronJob(schedule, this.execute.bind(this), null, true, 'UTC');
  }

  private async checkTablesExist(): Promise<boolean> {
    try {
      const tables = ['posts', 'common_topics', 'search_log'];
      for (const table of tables) {
        const exists = await db.schema.hasTable(table);
        if (!exists) {
          logger.warn(`Required table ${table} does not exist yet`);
          return false;
        }
      }
      return true;
    } catch (error) {
      logger.error('Error checking tables:', error as Error);
      return false;
    }
  }

  private async execute() {
    logger.info('Starting common topics generation');
    try {
      const tablesExist = await this.checkTablesExist();
      if (!tablesExist) {
        logger.info('Skipping common topics generation - required tables do not exist yet');
        return;
      }

      // Process search logs first
      logger.info('Generating topics from search logs');
      await commonTopicsService.generateCommonTopicsFromSearchLogs(this.timeframe);

      // Process each configured forum
      const forums = Object.keys(forumConfigs);
      logger.info(`Generating topics for ${forums.length} forums`);

      for (const forum of forums) {
        try {
          logger.info(`Generating topics for forum: ${forum}`);
          await commonTopicsService.generateCommonTopics(forum, this.timeframe);
          logger.info(`Completed topic generation for forum: ${forum}`);
        } catch (error) {
          logger.error(`Error generating topics for forum ${forum}:`, error as Error);
          // Continue with next forum even if one fails
          continue;
        }
      }

      logger.info('Completed common topics generation for all forums');
    } catch (error) {
      logger.error('Error in common topics cron job:', error as Error);
    }
  }

  start() {
    if (!this.job.running) {
      this.job.start();
      logger.info('Common topics cron job started');
    }
  }

  stop() {
    if (this.job.running) {
      this.job.stop();
      logger.info('Common topics cron job stopped');
    }
  }
}

================
File: services/cron/cronManager.ts
================
// services/cron/cronManager.ts
import { CronJob } from 'cron';
import { Logger } from '../logging';
import { CrawlerManager } from '../crawling/crawlerManager';
import { forumConfigs } from '../../config/forumConfig';

export class CronManager {
  private crawlJob: CronJob | null = null;
  private isEnabled: boolean = false;
  private schedule: string = '0 */2 * * *'; // Every 2 hours
  private lastRunTime: Date | null = null;
  private executionTimeout: ReturnType<typeof setTimeout> | null = null;
  private retryCount: number = 0;
  private readonly MAX_RETRIES = 3;
  private readonly EXECUTION_TIMEOUT = 30 * 60 * 1000; // 30 minutes
  private readonly RETRY_DELAY = 5 * 60 * 1000; // 5 minutes

  constructor(
    private readonly crawlerManager: CrawlerManager,
    private readonly logger: Logger
  ) {}

  startScheduledCrawls(cronSchedule?: string) {
    if (this.crawlJob) {
      this.logger.info('Stopping existing cron job before starting new one');
      this.stopScheduledCrawls();
    }

    if (cronSchedule) {
      try {
        new CronJob(cronSchedule, () => {}); // Validate schedule
        this.schedule = cronSchedule;
      } catch (error: any) {
        this.logger.error('Invalid cron schedule:', error);
        throw new Error('Invalid cron schedule provided');
      }
    }

    this.isEnabled = true;
    this.retryCount = 0;

    this.crawlJob = new CronJob(
      this.schedule,
      async () => {
        this.lastRunTime = new Date();
        await this.executeCrawlWithTimeout();
      },
      null,
      true,
      'UTC',
      null,
      true
    );

    this.logger.info(`Scheduled crawls enabled with schedule: ${this.schedule}`);
  }

  private executeCrawlWithTimeout(): Promise<void> {
    if (this.executionTimeout) {
      clearTimeout(this.executionTimeout);
    }

    return new Promise<void>((resolve, reject) => {
      this.executionTimeout = setTimeout(() => {
        this.logger.error('Crawl execution timeout reached');
        this.handleExecutionFailure('Crawl execution timeout');
        reject(new Error('Crawl execution timeout'));
      }, this.EXECUTION_TIMEOUT);

      const executeTask = async () => {
        try {
          const runningForums = this.crawlerManager
            .getAllStatuses()
            .filter(status => status.status === 'running');

          if (runningForums.length > 0) {
            this.logger.info('Skipping scheduled crawl - crawl already in progress', {
              runningForums: runningForums.map(f => f.forumName),
            });
            resolve();
            return;
          }

          for (const config of forumConfigs) {
            try {
              await this.crawlerManager.startCrawl(config.name);
              this.logger.info(`Completed crawl for ${config.name}`);
            } catch (error: any) {
              this.logger.error(`Failed indexing for ${config.name}:`, error);
              // Continue with other forums even if one fails
            }
          }

          this.retryCount = 0; // Reset retry count on successful execution
          resolve();
        } catch (error: any) {
          this.logger.error('Error during scheduled crawl:', error);
          this.handleExecutionFailure(error instanceof Error ? error.message : 'Unknown error');
          reject(error);
        } finally {
          if (this.executionTimeout) {
            clearTimeout(this.executionTimeout);
            this.executionTimeout = null;
          }
        }
      };

      executeTask();
    });
  }

  private handleExecutionFailure(errorMessage: string) {
    this.retryCount++;
    if (this.retryCount >= this.MAX_RETRIES) {
      this.logger.error(
        `Max retries (${this.MAX_RETRIES}) reached. Disabling scheduled crawls. Error: ${errorMessage}`
      );
      this.stopScheduledCrawls();
    } else {
      this.logger.warn(
        `Scheduling retry ${this.retryCount} of ${this.MAX_RETRIES} in ${this.RETRY_DELAY / 1000} seconds`
      );
      setTimeout(() => this.executeCrawlWithTimeout(), this.RETRY_DELAY);
    }
  }

  stopScheduledCrawls() {
    if (this.crawlJob) {
      this.crawlJob.stop();
      this.crawlJob = null;
    }

    if (this.executionTimeout) {
      clearTimeout(this.executionTimeout);
      this.executionTimeout = null;
    }

    this.isEnabled = false;
    this.retryCount = 0;
    this.logger.info('Scheduled crawls disabled');
  }

  getStatus() {
    return {
      enabled: this.isEnabled,
      schedule: this.schedule,
      nextRun: this.crawlJob ? this.crawlJob.nextDate().toString() : null,
      lastRun: this.lastRunTime?.toISOString() || null,
      isExecuting: this.executionTimeout !== null,
      retryCount: this.retryCount,
      maxRetries: this.MAX_RETRIES,
    };
  }
}

================
File: services/cron/jobTrackingService.ts
================
import db from '../../db/db';
import { Logger } from '../logging';

const logger = new Logger({
  logFile: 'logs/job-tracking.log',
  level: 'info',
});

export interface JobRecord {
  id: number;
  job_name: string;
  status: 'running' | 'success' | 'failed';
  message?: string;
  started_at: Date;
  completed_at?: Date;
  duration_ms?: number;
}

export class JobTrackingService {
  /**
   * Records the start of a job execution
   * @param jobName Unique identifier for the job
   * @returns The job record ID
   */
  async recordJobStart(jobName: string): Promise<number> {
    try {
      const [record] = await db('cron_job_history')
        .insert({
          job_name: jobName,
          status: 'running',
          started_at: new Date(),
        })
        .returning('id');

      logger.info(`Job started: ${jobName}, ID: ${record.id}`);
      return record.id;
    } catch (error) {
      logger.error(`Failed to record job start for ${jobName}:`, error as Error);
      // Return -1 to indicate failure but allow the job to continue
      return -1;
    }
  }

  /**
   * Records the completion of a job
   * @param jobId The job record ID
   * @param status The final status of the job
   * @param message Optional message with details about the job result
   */
  async recordJobCompletion(
    jobId: number,
    status: 'success' | 'failed',
    message?: string
  ): Promise<void> {
    // Skip if job tracking failed at start
    if (jobId === -1) return;

    try {
      const completedAt = new Date();
      const jobRecord = await db('cron_job_history').where('id', jobId).first();

      if (!jobRecord) {
        logger.warn(`Cannot complete job ${jobId}: record not found`);
        return;
      }

      const startedAt = new Date(jobRecord.started_at);
      const durationMs = completedAt.getTime() - startedAt.getTime();

      await db('cron_job_history')
        .where('id', jobId)
        .update({
          status,
          message: message || null,
          completed_at: completedAt,
          duration_ms: durationMs,
        });

      logger.info(
        `Job completed: ${jobRecord.job_name}, ID: ${jobId}, Status: ${status}, Duration: ${durationMs}ms`
      );
    } catch (error) {
      logger.error(`Failed to record job completion for ID ${jobId}:`, error as Error);
    }
  }

  /**
   * Gets the history of job executions
   * @param options Query options
   * @returns Array of job records
   */
  async getJobHistory(
    options: {
      jobName?: string;
      status?: 'running' | 'success' | 'failed';
      limit?: number;
      offset?: number;
    } = {}
  ): Promise<{ jobs: JobRecord[]; total: number }> {
    const { jobName, status, limit = 10, offset = 0 } = options;

    try {
      let query = db('cron_job_history').orderBy('started_at', 'desc');

      if (jobName) {
        query = query.where('job_name', jobName);
      }

      if (status) {
        query = query.where('status', status);
      }

      const jobs = await query.limit(limit).offset(offset);

      let countQuery = db('cron_job_history').count('id as count');
      if (jobName) {
        countQuery = countQuery.where('job_name', jobName);
      }
      if (status) {
        countQuery = countQuery.where('status', status);
      }

      const [total] = await countQuery;

      return {
        jobs,
        total: Number(total.count),
      };
    } catch (error) {
      logger.error('Failed to get job history:', error as Error);
      return { jobs: [], total: 0 };
    }
  }

  /**
   * Gets the last successful execution of a job
   * @param jobName The job name to look for
   * @returns The last successful job record or null
   */
  async getLastSuccessfulJob(jobName: string): Promise<JobRecord | null> {
    try {
      const record = await db('cron_job_history')
        .where('job_name', jobName)
        .where('status', 'success')
        .orderBy('completed_at', 'desc')
        .first();

      return record || null;
    } catch (error) {
      logger.error(`Failed to get last successful job for ${jobName}:`, error as Error);
      return null;
    }
  }
}

// Export a singleton instance
export const jobTrackingService = new JobTrackingService();

================
File: services/server/cron.ts
================
// services/server/cron.ts
import type { Context, Hono } from 'hono';
import { CronManager } from '../cron/cronManager';
import { Logger } from '../logging';

export const cronRoutes = (app: Hono, cronManager: CronManager, logger: Logger) => {
  // Get cron job status
  app.get('/api/cron/status', (c: Context) => {
    try {
      return c.json({
        ...cronManager.getStatus(),
        timestamp: new Date().toISOString(),
      });
    } catch (error: any) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      logger.error('Failed to get cron status', { error: errorMessage });
      return c.json(
        {
          error: 'Failed to get cron status',
          details: errorMessage,
          timestamp: new Date().toISOString(),
        },
        500
      );
    }
  });

  // Start cron job with optional schedule
  app.post('/api/cron/start', async (c: Context) => {
    try {
      let schedule: string | undefined;

      // Only try to parse body if content-type is application/json
      const contentType = c.req.header('content-type');
      if (contentType?.includes('application/json')) {
        const body = await c.req.json();
        schedule = body.schedule;
      }

      cronManager.startScheduledCrawls(schedule);

      return c.json({
        message: 'Cron job started successfully',
        status: cronManager.getStatus(),
        timestamp: new Date().toISOString(),
      });
    } catch (error: any) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      const errorStack = error instanceof Error ? error.stack : undefined;

      logger.error('Failed to start cron job', {
        error: errorMessage,
        stack: errorStack,
      });

      return c.json(
        {
          error: 'Failed to start cron job',
          details: errorMessage,
          stack: process.env.NODE_ENV === 'development' ? errorStack : undefined,
          timestamp: new Date().toISOString(),
        },
        500
      );
    }
  });

  // Stop cron job
  app.post('/api/cron/stop', (c: Context) => {
    try {
      cronManager.stopScheduledCrawls();
      return c.json({
        message: 'Cron job stopped successfully',
        status: cronManager.getStatus(),
        timestamp: new Date().toISOString(),
      });
    } catch (error: any) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      logger.error('Failed to stop cron job', { error: errorMessage });
      return c.json(
        {
          error: 'Failed to stop cron job',
          details: errorMessage,
          timestamp: new Date().toISOString(),
        },
        500
      );
    }
  });
};

================
File: services/server/cronStatusRoutes.ts
================
import { Hono } from 'hono';
import { Logger } from '../logging';
import { jobTrackingService } from '../cron/jobTrackingService';

const logger = new Logger({ logFile: 'logs/cron-status-routes.log', level: 'info' });

export const cronStatusRoutes = new Hono();

/**
 * Get job execution history
 * @route GET /api/cron/job-history
 * @query {string} [job_name] - Filter by job name
 * @query {string} [status] - Filter by status (running, success, failed)
 * @query {number} [limit=10] - Number of records to return
 * @query {number} [offset=0] - Number of records to skip
 * @returns {object} Job history records with pagination info
 */
cronStatusRoutes.get('/api/cron/job-history', async c => {
  try {
    const jobName = c.req.query('job_name');
    const status = c.req.query('status') as 'running' | 'success' | 'failed' | undefined;
    const limit = parseInt(c.req.query('limit') || '10');
    const offset = parseInt(c.req.query('offset') || '0');

    const { jobs, total } = await jobTrackingService.getJobHistory({
      jobName,
      status,
      limit,
      offset,
    });

    return c.json({
      jobs,
      pagination: {
        total,
        limit,
        offset,
        has_more: offset + jobs.length < total,
      },
      timestamp: new Date().toISOString(),
    });
  } catch (error) {
    logger.error('Error fetching job history:', error);
    return c.json(
      {
        error: 'Failed to fetch job history',
        details: error instanceof Error ? error.message : 'Unknown error',
        timestamp: new Date().toISOString(),
      },
      500
    );
  }
});

/**
 * Get health status of topic generation jobs
 * @route GET /api/health/topics-generation
 * @returns {object} Health status information
 */
cronStatusRoutes.get('/api/health/topics-generation', async c => {
  try {
    // Check last successful run of any topic generation job
    const lastSuccess = await jobTrackingService.getLastSuccessfulJob('generate_all_topics');

    // If no generate_all_topics job found, check for individual forum jobs
    let lastRunTime = lastSuccess?.completed_at;
    let jobName = lastSuccess?.job_name;

    if (!lastRunTime) {
      // Look for any forum-specific job
      const forumJob = await jobTrackingService.getLastSuccessfulJob('generate_topics_%');
      if (forumJob) {
        lastRunTime = forumJob.completed_at;
        jobName = forumJob.job_name;
      }
    }

    // Calculate time since last run
    const now = new Date();
    const hoursSinceLastRun = lastRunTime
      ? Math.round((now.getTime() - new Date(lastRunTime).getTime()) / (60 * 60 * 1000))
      : null;

    // Check status based on expected daily run
    const status = !lastRunTime
      ? 'never_run'
      : hoursSinceLastRun > 36
        ? 'critical'
        : hoursSinceLastRun > 25
          ? 'warning'
          : 'healthy';

    return c.json({
      service: 'topic-generation',
      status,
      last_success: lastRunTime
        ? {
            job: jobName,
            time: lastRunTime,
            hours_ago: hoursSinceLastRun,
          }
        : null,
      timestamp: now.toISOString(),
    });
  } catch (error) {
    logger.error('Error checking topic generation health:', error);
    return c.json(
      {
        service: 'topic-generation',
        status: 'error',
        error: error instanceof Error ? error.message : 'Unknown error',
        timestamp: new Date().toISOString(),
      },
      500
    );
  }
});

/**
 * Manually trigger topic generation for all forums
 * @route POST /api/cron/run-topic-generation
 * @body {string} [timeframe='14d'] - Time range for topic generation
 * @returns {object} Status message
 */
cronStatusRoutes.post('/api/cron/run-topic-generation', async c => {
  try {
    // Check for API key if configured
    if (process.env.CRON_API_KEY) {
      const apiKey = c.req.header('X-API-Key');
      if (apiKey !== process.env.CRON_API_KEY) {
        logger.warn('Unauthorized attempt to run topic generation - invalid API key');
        return c.json({ error: 'Unauthorized', code: 'UNAUTHORIZED' }, 401);
      }
    }

    // Forward the request to the generate-all endpoint
    const response = await fetch(
      `${c.req.url.split('/api/cron')[0]}/api/common-topics/generate-all`,
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-API-Key': process.env.CRON_API_KEY || '',
        },
        body: c.req.raw.body,
      }
    );

    const result = await response.json();
    return c.json(result, response.status);
  } catch (error) {
    logger.error('Error triggering topic generation:', error);
    return c.json(
      {
        error: 'Failed to trigger topic generation',
        details: error instanceof Error ? error.message : 'Unknown error',
        timestamp: new Date().toISOString(),
      },
      500
    );
  }
});
